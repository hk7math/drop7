<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Drop7 - Final Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body { background: #0a0a0c; color: #fff; font-family: 'Inter', sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; touch-action: none; overflow: hidden; height: 100vh; }
        #hud { width: 350px; display: flex; justify-content: space-around; padding: 20px 0; background: #111; border-bottom: 2px solid #333; }
        .stat { text-align: center; }
        .label { font-size: 10px; color: #888; display: block; letter-spacing: 1px; margin-bottom: 4px; }
        .val { font-size: 24px; font-weight: bold; font-variant-numeric: tabular-nums; }
        #game-area { position: relative; width: 350px; height: 400px; margin-top: 20px; }
        canvas { background: #111; border: 4px solid #1a1a1a; display: block; cursor: pointer; border-radius: 8px; }
        #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 999; border-radius: 8px; }
        button { background: #FFD700; border: none; padding: 12px 30px; font-weight: bold; border-radius: 5px; cursor: pointer; color: #000; font-size: 16px; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat"><span class="label">SCORE</span><span id="score" class="val">0</span></div>
        <div class="stat"><span class="label">FLOOR IN</span><span id="moves" class="val">5</span></div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas" width="350" height="400"></canvas>
        <div id="overlay">
            <h1 style="color:#FFD700; margin-bottom:10px;">GAME OVER</h1>
            <button onclick="location.reload()">TRY AGAIN</button>
        </div>
    </div>

<script>
const SUPABASE_URL = 'https://pspgokziawpuhjrmsnhw.supabase.co';
const SUPABASE_KEY = 'sb_publishable_D6d77UoUxIqVC9nsriL0Ig_ouLktESd';
let supabaseClient = null;
try { supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY); } catch(e){}

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ROWS = 7, COLS = 7, SIZE = 50, OFFSET_Y = 50;

let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
let score = 0, movesLeft = 5, comboCount = 0, isBusy = false;
let nextVal = Math.floor(Math.random() * 7) + 1;
let previewCol = 3;

class Disc {
    constructor(val, col, y, type = 'num', health = 1) {
        this.val = val; this.col = col; this.y = y; this.targetY = y;
        this.type = type; this.health = health;
    }
    update() {
        if (Math.abs(this.targetY - this.y) > 0.1) {
            this.y += (this.targetY - this.y) * 0.35;
        } else {
            this.y = this.targetY;
        }
    }
    draw() {
        const colors = ["#444", "#FF5D5D", "#4BB543", "#3B82F6", "#A855F7", "#FACC15", "#2DD4BF", "#F97316"];
        ctx.beginPath();
        ctx.arc(this.col * SIZE + SIZE/2, this.y, SIZE/2 - 4, 0, Math.PI*2);
        ctx.fillStyle = this.type === 'gray' ? (this.health === 2 ? "#333" : "#999") : colors[this.val];
        ctx.fill();
        if(this.type === 'num') {
            ctx.fillStyle = "white"; ctx.font = "bold 20px Inter, sans-serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText(this.val, this.col * SIZE + SIZE/2, this.y);
        }
    }
}

function checkMoving() {
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(board[r][c] && Math.abs(board[r][c].y - board[r][c].targetY) > 0.5) return true;
        }
    }
    return false;
}

async function waitMoving() {
    return new Promise(resolve => {
        let timeout = setTimeout(resolve, 2000); // Failsafe
        const check = () => {
            if (!checkMoving()) { clearTimeout(timeout); resolve(); }
            else requestAnimationFrame(check);
        };
        check();
    });
}

async function handleDrop(col) {
    if (isBusy || checkMoving()) return;
    
    let targetR = -1;
    for (let r = ROWS - 1; r >= 0; r--) { if (!board[r][col]) { targetR = r; break; } }
    
    if (targetR !== -1) {
        isBusy = true;
        comboCount = 0;
        
        board[targetR][col] = new Disc(nextVal, col, 25, 'num');
        board[targetR][col].targetY = targetR * SIZE + SIZE/2 + OFFSET_Y;
        nextVal = Math.floor(Math.random() * 7) + 1;

        await waitMoving();
        await runChains();

        movesLeft--;
        if (movesLeft <= 0) {
            await riseFloor();
            movesLeft = 5;
        }
        
        document.getElementById('moves').innerText = movesLeft;
        isBusy = false; // Disc only appears when this is false
    }
}

async function runChains() {
    let changed = true;
    while (changed) {
        await waitMoving();
        let toPop = [];

        for(let r=0; r<ROWS; r++) {
            let start = -1;
            for(let c=0; c<=COLS; c++) {
                if(c < COLS && board[r][c]) { if(start === -1) start = c; }
                else if(start !== -1) {
                    let count = c - start;
                    for(let i=start; i<c; i++) if(board[r][i]?.type === 'num' && board[r][i].val === count) toPop.push({r, c:i});
                    start = -1;
                }
            }
        }
        for(let c=0; c<COLS; c++) {
            let count = board.filter(row => row[c]).length;
            for(let r=0; r<ROWS; r++) if(board[r][c]?.type === 'num' && board[r][c].val === count) toPop.push({r, c});
        }

        if (toPop.length > 0) {
            comboCount++;
            await new Promise(res => setTimeout(res, 250));
            toPop.forEach(p => {
                if(!board[p.r][p.c]) return;
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc])=>{
                    let nr=p.r+dr, nc=p.c+dc;
                    if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && board[nr][nc]?.type === 'gray'){
                        board[nr][nc].health--;
                        if(board[nr][nc].health <= 0) { board[nr][nc].type = 'num'; board[nr][nc].val = Math.floor(Math.random()*7)+1; }
                    }
                });
                board[p.r][p.c] = null;
                score += (7 * Math.pow(comboCount, 3)) - (21 * Math.pow(comboCount, 2)) + (35 * comboCount) - 14;
            });
            document.getElementById('score').innerText = Math.floor(score).toLocaleString();
            gravity();
        } else {
            changed = false;
        }
    }
}

function gravity() {
    for (let c = 0; c < COLS; c++) {
        let items = [];
        for (let r = 0; r < ROWS; r++) if (board[r][c]) items.push(board[r][c]);
        for (let r = ROWS - 1; r >= 0; r--) {
            board[r][c] = items.pop() || null;
            if (board[r][c]) board[r][c].targetY = r * SIZE + SIZE/2 + OFFSET_Y;
        }
    }
}

async function riseFloor() {
    // Check if game over (top row filled)
    for(let c=0; c<COLS; c++) if(board[0][c]) { document.getElementById('overlay').style.display='flex'; isBusy = true; return; }
    
    // Shift everything up
    for (let r = 0; r < ROWS - 1; r++) {
        board[r] = board[r+1];
        board[r].forEach(d => { if(d) d.targetY -= SIZE; });
    }

    // New bottom row
    board[ROWS-1] = Array(COLS).fill(0).map((_, c) => {
        let d = new Disc(0, c, (ROWS)*SIZE + SIZE/2 + OFFSET_Y, 'gray', 2);
        d.targetY = (ROWS-1)*SIZE + SIZE/2 + OFFSET_Y;
        return d;
    });

    await waitMoving();
    await runChains();
}

function draw() {
    ctx.clearRect(0,0,350,400);
    ctx.strokeStyle = "#222";
    for(let i=0; i<=COLS; i++) { ctx.beginPath(); ctx.moveTo(i*SIZE, OFFSET_Y); ctx.lineTo(i*SIZE, 400); ctx.stroke(); }
    for(let i=0; i<=ROWS; i++) { ctx.beginPath(); ctx.moveTo(0, i*SIZE + OFFSET_Y); ctx.lineTo(350, i*SIZE + OFFSET_Y); ctx.stroke(); }

    if(!isBusy) {
        new Disc(nextVal, previewCol, 25).draw();
    }

    for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) if(board[r][c]) { board[r][c].update(); board[r][c].draw(); }
    requestAnimationFrame(draw);
}

const onInput = (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX || (e.touches && e.touches[0].clientX)) - rect.left);
    previewCol = Math.floor(Math.max(0, Math.min(x, 349)) / SIZE);
    if (e.type === 'pointerdown' || e.type === 'mousedown') handleDrop(previewCol);
};

canvas.addEventListener('pointermove', onInput);
canvas.addEventListener('pointerdown', onInput);
draw();
</script>
</body>
</html>
